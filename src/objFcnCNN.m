function [objFcn] = objFcnCNN(p, t, pv, tv, inputName)
    objFcn = @valErrorFcn;
    function [valError, cons, fileName] = valErrorFcn(optVars)

        [pImg, tImg] = datasetTimeseriesToImg(p, t, inputName, optVars.ImageHeight);
        [pvImg, tvImg] = datasetTimeseriesToImg(pv, tv, inputName, optVars.ImageHeight);

        layers = [
               imageInputLayer([ESPConst.N_INPUT_FEATURES, optVars.ImageHeight, 1])
               convolution2dLayer([optVars.FilterSizeX optVars.FilterSizeY], optVars.NumFilters)
               fullyConnectedLayer(ESPConst.N_OUTPUT_CLASSES_ALL)
               softmaxLayer
               classificationLayer
                 ];
        validationFrequency = floor(numel(t) / optVars.MiniBatchSize);

        options = trainingOptions(string(optVars.Solver), ...
            'InitialLearnRate', optVars.InitialLearnRate, ...
            'MaxEpochs', optVars.MaxEpochs, ...
            'SequencePaddingDirection', "left", ...
            'Shuffle', "every-epoch", ...
            'LearnRateSchedule', 'piecewise', ...
            'LearnRateDropPeriod', round(optVars.MaxEpochs / 3), ...
            'LearnRateDropFactor', optVars.LearnRateDropFactor, ...
            'MiniBatchSize', optVars.MiniBatchSize, ...
            'L2Regularization', optVars.L2Regularization, ...
            'ExecutionEnvironment', "cpu", ...
            'Verbose', true, ...
            'Plots', 'training-progress', ...
            'ValidationData', {pvImg, tvImg}, ...
            'ValidationFrequency', validationFrequency);

        if optVars.Solver == "sgdm"
            options.Momentum = optVars.Momentum;
        end

        tNN = trainNetwork(pImg, tImg, layers, options);
        predicted = classify(tNN, pvImg);
        valError =  1 - mean(predicted == transpose(tvImg));
        fileName = num2str(valError) + "_CNN_" + inputName;
        save(ESPConst.PATH_CNNS + fileName, 'tNN','valError','options');
        cons = [];
    end
end